
// This module handles the conversion of thesis data to LaTeX, using a preselected template.
// Sections expected: Portada (from meta), Introducción, Capítulos (can be multiple), Conclusiones.
// Índice (table of contents) and Bibliografía (bibliography) are auto-generated by LaTeX commands in the template.
// Example section structure:
// [
//   { id: "intro", title: "Introducción", level: 1, content: "..." },
//   { id: "chapters", title: "Capítulos", level: 1, children: [
//     { id: "ch1", title: "Capítulo 1", level: 2, content: "..." },
//     // ...more chapters
//   ]},
//   { id: "conclusions", title: "Conclusiones", level: 1, content: "..." }
// ]

// Mapea niveles -> comandos LaTeX
const LEVEL_CMD = {
  1: "\\section",
  2: "\\subsection",
  3: "\\subsubsection",
  4: "\\paragraph"
};

// Escapa caracteres problemáticos de LaTeX
export function escapeLatex(s = "") {
  return String(s)
    .replace(/\\/g, "\\textbackslash{}")
    .replace(/([#%&_$])/g, "\\$1")
    .replace(/{/g, "\\{")
    .replace(/}/g, "\\}")
    .replace(/\^/g, "\\textasciicircum{}")
    .replace(/~/g, "\\textasciitilde{}");
}

// Markdown muy ligero -> LaTeX
export function mdToLatex(md = "") {
  let s = String(md);

  // citas: [@clave] -> \autocite{clave}
  s = s.replace(/\[@([\w:-]+)\]/g, "\\autocite{$1}");

  // negritas: **x** -> \textbf{x}
  s = s.replace(/\*\*([^*]+)\*\*/g, "\\textbf{$1}");

  // cursivas: *x* -> \textit{x}
  s = s.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, "\\textit{$1}");

  // código inline: `x` -> \texttt{x}
  s = s.replace(/`([^`]+)`/g, "\\texttt{$1}");

  // enlaces: [texto](url) -> \href{url}{texto}
  s = s.replace(/\[([^\]]+)\]\(([^)]+)\)/g, "\\href{$2}{$1}");

  // listas con "- " al inicio de línea -> itemize
  s = s.replace(/^\s*-\s+(.*)$/gm, "\\item $1");
  s = s.replace(/((?:\\item .*(?:\n|$))+)/g, (m) => `\\begin{itemize}\n${m}\\end{itemize}`);

  return s;
}

// Renderiza una sección y sus hijas
export function renderSection(sec) {
  const cmd = LEVEL_CMD[sec?.level] || "\\paragraph";
  const title = escapeLatex(sec?.title || "Untitled");
  const body = mdToLatex(sec?.content || "");
  const children = (sec?.children || []).map(renderSection).join("\n\n");

  // Render images, tables, and equations (if provided in the section object)
  const images = (sec?.images || []).map((img) => {
    // img: { filename, caption, width }
    const caption = escapeLatex(img.caption || "");
    const width = img.width ? `[width=${img.width}]` : "";
    return `\\begin{figure}[h]\n\\centering\n\\includegraphics${width}{${img.filename}}\n${caption ? `\\caption{${caption}}\n` : ""}\\end{figure}`;
  }).join("\n\n");

  const tables = (sec?.tables || []).map((t) => {
    // t: { csv, caption }
    const rows = String(t.csv || "").split(/\r?\n/).filter(Boolean).map(r => r.split(/\s*,\s*/));
    if (!rows.length) return "";
    const cols = rows[0].length;
    const colSpec = Array(cols).fill("l").join("|");
    const bodyRows = rows.map(r => r.map(cell => escapeLatex(cell || "")).join(" & \\ ")).join(" \\\n+");
    const caption = escapeLatex(t.caption || "");
    return `\\begin{table}[h]\n\\centering\n\\begin{tabular}{|${colSpec}|}\n\\hline\n${bodyRows}\\\\\n\\hline\n\\end{tabular}\n${caption ? `\\caption{${caption}}\n` : ""}\\end{table}`;
  }).join("\n\n");

  const equations = (sec?.equations || []).map((eq) => {
    // eq: { latex, caption }
    const caption = escapeLatex(eq.caption || "");
    const latex = String(eq.latex || "");
    const displayed = `\\[\n${latex}\n\\]`;
    return `${displayed}${caption ? `\n\\begin{center}\n\\textit{${caption}}\n\\end{center}` : ""}`;
  }).join("\n\n");

  const extras = [images, tables, equations].filter(Boolean).join("\n\n");

  return `${cmd}{${title}}\n\n${body}\n\n${extras}\n\n${children}`.trim();
}

// Ensambla todas las secciones (separadas por \clearpage)
export function renderContent(sections = []) {
  return sections.map(renderSection).join("\n\n\\clearpage\n\n");
}

// Plantilla por defecto (puedes sobreescribirla desde la UI)
export const DEFAULT_TEMPLATE = String.raw`% Auto-generated by Thesis Builder
\documentclass[12pt]{report}
\usepackage[margin=1in]{geometry}
\usepackage{setspace}\onehalfspacing
\usepackage[hidelinks]{hyperref}
\usepackage{graphicx}
\usepackage{amsmath, amssymb}
\usepackage{csquotes}
\usepackage[backend=biber,style=apa]{biblatex}
\addbibresource{references.bib}
\usepackage[absolute,overlay]{textpos}


% Portada (cover) se genera de meta: title, author, date
\title{\MakeUppercase{\VARtitle}}
\author{\VARauthor}
\date{\VARdate}

\begin{document}
\maketitle
% Índice (table of contents) se autogenera
\tableofcontents
\cleardoublepage

% === CONTENT START ===
\VARcontent
% === CONTENT END ===

\cleardoublepage
% Bibliografía (bibliography) se autogenera
\printbibliography
\end{document}
`;

// buildTex: inserta meta + contenido en la plantilla LaTeX
export function buildTex(template, thesis) {
  const tpl = template && template.trim().length ? template : DEFAULT_TEMPLATE;

  const meta = thesis?.meta || {};
  const sections = thesis?.sections || [];

  const filled = tpl
    .replace("\\VARtitle", escapeLatex(meta.title || "Thesis Title"))
    .replace("\\VARauthor", escapeLatex(meta.author || "Author"))
    .replace("\\VARdate", escapeLatex(meta.date || "\\today"))
    .replace(
      /% === CONTENT START ===[\s\S]*% === CONTENT END ===/,
      `% === CONTENT START ===\n${renderContent(sections)}\n% === CONTENT END ===`
    );

  return filled;
}
