
// This module handles the conversion of thesis data to LaTeX, using a preselected template.
// Sections expected: Portada (from meta), Introducción, Capítulos (can be multiple), Conclusiones.
// Índice (table of contents) and Bibliografía (bibliography) are auto-generated by LaTeX commands in the template.
// Example section structure:
// [
//   { id: "intro", title: "Introducción", level: 1, content: "..." },
//   { id: "chapters", title: "Capítulos", level: 1, children: [
//     { id: "ch1", title: "Capítulo 1", level: 2, content: "..." },
//     // ...more chapters
//   ]},
//   { id: "conclusions", title: "Conclusiones", level: 1, content: "..." }
// ]

// Mapea niveles -> comandos LaTeX
const LEVEL_CMD = {
  1: "\\section",
  2: "\\subsection",
  3: "\\subsubsection",
  4: "\\paragraph"
};

// Escapa caracteres problemáticos de LaTeX
export function escapeLatex(s = "") {
  return String(s)
    .replace(/\\/g, "\\textbackslash{}")
    .replace(/([#%&_$])/g, "\\$1")
    .replace(/{/g, "\\{")
    .replace(/}/g, "\\}")
    .replace(/\^/g, "\\textasciicircum{}")
    .replace(/~/g, "\\textasciitilde{}");
}

// Markdown muy ligero -> LaTeX
export function mdToLatex(md = "") {
  let s = String(md);

  // citas: [@clave] -> \autocite{clave}
  s = s.replace(/\[@([\w:-]+)\]/g, "\\autocite{$1}");

  // negritas: **x** -> \textbf{x}
  s = s.replace(/\*\*([^*]+)\*\*/g, "\\textbf{$1}");

  // cursivas: *x* -> \textit{x}
  s = s.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, "\\textit{$1}");

  // código inline: `x` -> \texttt{x}
  s = s.replace(/`([^`]+)`/g, "\\texttt{$1}");

  // enlaces: [texto](url) -> \href{url}{texto}
  s = s.replace(/\[([^\]]+)\]\(([^)]+)\)/g, "\\href{$2}{$1}");

  // listas con "- " al inicio de línea -> itemize
  s = s.replace(/^\s*-\s+(.*)$/gm, "\\item $1");
  s = s.replace(/((?:\\item .*(?:\n|$))+)/g, (m) => `\\begin{itemize}\n${m}\\end{itemize}`);

  return s;
}

// Renderiza una sección y sus hijas
export function renderSection(sec) {
  let cmd = LEVEL_CMD[sec?.level] || "\\paragraph";
  if (sec?.unnumbered) {
    cmd = cmd.replace("\\", "\\") + "*"; // e.g., \section*
  }

  const title = escapeLatex(sec?.title || "Untitled");

  let body = "";

  // Helper to render specific block types
  const renderBlock = (block) => {
    if (!block) return "";
    switch (block.type) {
      case 'text':
        return mdToLatex(block.content || "");
      case 'image':
        // img: { filename, caption, width }
        {
          // If caption is empty, we force a specific string or at least an empty caption so it appears in the List of Figures
          const captionRaw = block.caption && block.caption.trim() !== "" ? block.caption : "Figura";
          const caption = escapeLatex(captionRaw);
          // Default to \linewidth to ensure image fits within page margins
          const width = block.width ? `[width=${block.width}]` : "[width=\\linewidth]";
          return `\\begin{figure}[h]\n\\centering\n\\includegraphics${width}{images/${block.filename}}\n\\caption{${caption}}\n\\end{figure}`;
        }
      case 'table':
        // t: { rows, cols, data, caption }
        {
          const rows = block.rows;
          const cols = block.cols;
          const colSpec = "c".repeat(cols); // Simple centering for all cols
          let tableContent = "";
          for (let i = 0; i < rows; i++) {
            const rowData = [];
            for (let j = 0; j < cols; j++) {
              rowData.push(escapeLatex(block.data[`${i}-${j}`] || ""));
            }
            tableContent += rowData.join(" & ") + " \\\\\n";
          }
          const captionRaw = block.caption && block.caption.trim() !== "" ? block.caption : "Tabla";
          const caption = escapeLatex(captionRaw);
          return `\\begin{table}[h]\n\\centering\n\\begin{tabular}{|${colSpec}|}\n\\hline\n${tableContent}\\hline\n\\end{tabular}\n\\caption{${caption}}\n\\end{table}`;
        }
      case 'equation':
        return `\\begin{equation}\n${block.content}\n\\end{equation}`;
      default:
        return "";
    }
  };

  if (sec?.blocks && Array.isArray(sec.blocks)) {
    // NEW BLOCK STRUCTURE
    body = sec.blocks.map(renderBlock).join("\n\n");
  } else {
    // BACKWARD COMPATIBILITY
    body = mdToLatex(sec?.content || "");

    const images = (sec?.images || []).map((img) => renderBlock({ type: 'image', ...img })).join("\n\n");
    const tables = (sec?.tables || []).map((t) => renderBlock({ type: 'table', ...t })).join("\n\n");
    const equations = (sec?.equations || []).map((eq) => renderBlock({ type: 'equation', ...eq })).join("\n\n");

    const extras = [images, tables, equations].filter(Boolean).join("\n\n");
    if (extras) body += "\n\n" + extras;
  }

  const children = (sec?.children || []).map(renderSection).join("\n\n");

  return `${cmd}{${title}}\n\n${body}\n\n${children}`.trim();
}

// Ensambla todas las secciones (separadas por \clearpage)
export function renderContent(sections = []) {
  return sections.map(renderSection).join("\n\n\\clearpage\n\n");
}

// Plantilla por defecto (puedes sobreescribirla desde la UI)
export const DEFAULT_TEMPLATE = String.raw`% Auto-generated by Thesis Builder
\documentclass[12pt]{report}
\usepackage[margin=1in]{geometry}
\usepackage[spanish]{babel}
\usepackage{setspace}\onehalfspacing
\usepackage[hidelinks]{hyperref}
\usepackage{graphicx}
\usepackage{amsmath, amssymb}
\usepackage{csquotes}
\usepackage[backend=biber,style=apa]{biblatex}
\addbibresource{references.bib}
\usepackage[absolute,overlay]{textpos}


% Portada (cover) se genera de meta: title, author, date
\title{\MakeUppercase{\VARtitle}}
\author{\VARauthor}
\date{\VARdate}

\begin{document}
\maketitle

% Dedicatoria
\VARdedication

% Agradecimientos
\VARacknowledgements

% Índice (table of contents) se autogenera
\tableofcontents
\cleardoublepage

% === CONTENT START ===
\VARcontent
% === CONTENT END ===

\cleardoublepage
% Bibliografía (bibliography) se autogenera
\nocite{*}
\printbibliography

\cleardoublepage
\addcontentsline{toc}{section}{Glosario de Anexos}
\listoffigures
\listoftables

\end{document}
`;

// buildTex: inserta meta + contenido en la plantilla LaTeX
export function buildTex(template, thesis) {
  const tpl = template && template.trim().length ? template : DEFAULT_TEMPLATE;

  const meta = thesis?.meta || {};
  const sections = thesis?.sections || [];

  const filled = tpl
    .replace("\\VARtitle", escapeLatex(meta.title || "Thesis Title"))
    .replace("\\VARauthor", escapeLatex(meta.author || "Author"))
    .replace("\\VARdate", escapeLatex(meta.date || "\\today"))
    .replace("\\VARdedication", meta.dedication ? `\\clearpage\n\\thispagestyle{empty}\n\\vspace*{\\fill}\n\\begin{flushright}\n\\textit{${escapeLatex(meta.dedication)}}\n\\end{flushright}\n\\vspace*{\\fill}` : "")
    .replace("\\VARacknowledgements", meta.acknowledgements ? `\\clearpage\n\\section*{Agradecimientos}\n${mdToLatex(meta.acknowledgements)}` : "")
    .replace(
      /% === CONTENT START ===[\s\S]*% === CONTENT END ===/,
      `% === CONTENT START ===\n${renderContent(sections)}\n% === CONTENT END ===`
    );

  return filled;
}
